'''
Joshua Meyer

Simulating a Hidden Markov Model

USAGE: $ python3 hmm.py
'''
import numpy as np
import random

class HMM:
    def __init__(self):
        # look-up tables for emissions and states
        self.S = ['state1','state2']
        self.K = ['a', 'b']
        
        # array of initial state probabilities
        self.PI = np.matrix([1.0,
                             0.0],
                            dtype=float)

        # matrix of state transition probabilities
        self.A = np.matrix([[0.5, 0.5],
                            [0.7, 0.3]],
                           dtype=float)


        # matrix of emission probabilities
        self.B = np.matrix([[0.4, 0.6],
                            [0.1, 0.9]],
                           dtype=float)

        
    def forward_algorithm(self, O):
        '''
        Given some input string O, calculate the probability that
        it was generated by the HMM (specs in __init__).
        p(O|model)

        \Sigma_{X_1 ... X_{T+1}} \pi_{X_i} \prod_{t+1}^{T} a_{X_t X_{t+1}} 
        \cdot b_{X_t,X_t+1} o_t

        '''
        # create matrix to hold local probailities
        Trellis = np.zeros((len(self.S),
                                 len(O)),
                                dtype=float)
        
        # append initial state probs
        Trellis = np.concatenate((self.PI.T,Trellis), axis=1)

        trellisCol=1
        for emission in O:
            emissionIndex = self.K.index(emission)
            for state_i in range(len(self.S)):
                combinedProb = 0
                for state_j in range(len(self.S)):
                    previousProb_j = Trellis[state_j,(trellisCol-1)]
                    transProb = self.A[state_j,state_i]
                    emissionProb = self.B[state_i,emissionIndex]
                    combinedProb += previousProb_j*transProb*emissionProb
                Trellis[state_i,trellisCol] = combinedProb
            trellisCol+=1
        return Trellis

    def compute_max_likelihood(self, O):
        Trellis = self.forward_algorithm(O)
        MLE = np.sum(Trellis, axis=0)[0,-1]
        print('FORWARD ALGORITHM TRELLIS:')
        print(Trellis)
        print('MAXIMUM LIKELIHOOD ESTIMATION:')
        print(O, str(MLE))
        
    def get_best_path(self,Trellis):
        # delete the first column (start states) before printing
        noStartTrellis = np.delete(Trellis,obj=0,axis=1)
        stateIndeces = np.array(noStartTrellis.argmax(axis=0))[0]
        mostProbStates = [self.S[i] for i in stateIndeces]
        highestProbs = noStartTrellis.max(axis=0)
        return mostProbStates, highestProbs
        
def cartesian_product(arrays, cartesianProdArray=None):
    """
    Generate a cartesian product of input arrays.

    INPUT
    arrays : list of array-like
        1-D arrays to form the cartesian product of.
    cartesianProdArray : ndarray
        Array to place the cartesian product in.

    OUTPUT
    cartesianProdArray : ndarray
        2-D array of shape (M, len(arrays)) containing cartesian products
        formed of input arrays.

    EXAMPLE
    >>> cartesian(([1], [4, 5], [6, 7]))
    array([[1, 4, 6],
           [1, 4, 7],
           [1, 5, 6],
           [1, 5, 7]])
    """
    # take the input (array_like: lists, tuples, matrices) and convert to array
    arrays = [np.asarray(x) for x in arrays]
    # take the datatype from the first of the arrays
    dtype = arrays[0].dtype

    # find the length of the output array
    n = np.prod([x.size for x in arrays])
    # initialize empty array
    if cartesianProdArray is None:
        cartesianProdArray = np.zeros([n, len(arrays)], dtype=dtype)

    m = n / arrays[0].size
    cartesianProdArray[:,0] = np.repeat(arrays[0], m)
    if arrays[1:]:
        cartesian_product(arrays[1:],
                          cartesianProdArray=cartesianProdArray[0:m,1:])
        for j in range(1, arrays[0].size):
            cartesianProdArray[j*m:(j+1)*m,1:] = cartesianProdArray[0:m,1:]
    return cartesianProdArray


def generate_string(hmm):
    len1sentences = cartesian_product([hmm.K]*1)
    len2sentences = cartesian_product([hmm.K]*2)
    len3sentences = cartesian_product([hmm.K]*3)

    for sentences in [len1sentences,len2sentences,len3sentences]:
        for sentence in sentences:
            Trellis = hmm.forward_algorithm(sentence)
            states, probs = hmm.get_best_path(Trellis)

            tags = (' ').join(states)
            sentence = ('').join(np.array(sentence))
            jointProb = np.prod(probs)
            # latex booktabs format
            tableLine = (sentence+'\t& '+tags+'\t& '+str(jointProb)+r'\\')
            print(tableLine)


            
if __name__ == "__main__":
    hmm = HMM()
    print('STATES:')
    print(hmm.S)
    print('ALPHABET:')
    print(hmm.K)
    o = input('Enter observation here with spaces: ')
    o = o.split(' ')
    hmm.compute_max_likelihood(o)

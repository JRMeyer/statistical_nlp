'''
Joshua Meyer

Simulating a Hidden Markov Model

USAGE: $ python q2.py
'''
import numpy as np
import random

class HMM:
    def __init__(self):
        # number of states in model
        self.N = 3
        # number of elements in emissions alphabet
        self.M = 3
        # array of initial state probabilities
        self.PI = np.matrix([0.3, 0.5, 0.2],
                      dtype=float)
        # matrix of state transition probabilities
        self.A = np.matrix([[0.2, 0.6, 0.2],
                           [0.3, 0.3, 0.4],
                           [0.1, 0.8, 0.1]],
                          dtype=float)
        # matrix of emission probabilities
        self.B = np.matrix([[0.3, 0.1, 0.6],
                           [0.5, 0.3, 0.2],
                           [0.1, 0.7, 0.2]],
                          dtype=float)
        # look-up tables for emissions and states
        self.S = ['1','2','3']
        self.K = ['a','b','c']

    
    def generate_string(self):
        pass
    
    def forward_algorithm(self, O):
        '''
        Given some input string O, calculate the probability that
        it was generated by the HMM (specs in __init__).
        p(O|model)

        \Sigma_{X_1 ... X_{T+1}} \pi_{X_i} \prod_{t+1}^{T} a_{X_t X_{t+1}} 
        \cdot b_{X_t,X_t+1} o_t

        '''
        # create matrix to hold local probailities
        Trellis = np.zeros((len(self.S),
                                 len(O)),
                                dtype=float)
        
        # append initial state probs
        Trellis = np.concatenate((self.PI.T,Trellis), axis=1)

        trellisCol=1
        for emission in O:
            emissionIndex = self.K.index(emission)
            for state_i in range(len(self.S)):
                combinedProb = 0
                for state_j in range(len(self.S)):
                    previousProb_j = Trellis[state_j,(trellisCol-1)]
                    transProb = self.A[state_j,state_i]
                    emissionProb = self.B[state_i,emissionIndex]
                    combinedProb += previousProb_j*transProb*emissionProb
                Trellis[state_i,trellisCol] = combinedProb
            trellisCol+=1
        return Trellis

    def print_best_states_from_trellis(self,Trellis):
        # delete the first entry from start states before printing
        print(np.delete(Trellis.argmax(axis=0),obj=0,axis=1))

    
if __name__ == "__main__":
    hmm = HMM()
    _string = input("enter string: ")
    Trellis = hmm.forward_algorithm(_string)
    hmm.print_best_states_from_trellis(Trellis)

    
# how to generate things (from tutorial)
# (1) choose initial state from PI
# (2) set t = 1
# (3) chose emission from initial state (B) 
# (4) transition to new state (A)
# (5) increment t and go to (3) 
